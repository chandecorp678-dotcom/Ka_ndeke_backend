<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ka Ndeke ‚Äì Aviator (fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #081a2b; color: #fff; text-align: center; }
    header { background: #03101f; padding: 10px; display: flex; justify-content: space-between; align-items: center; }
    header h1 { margin: 0; font-size: 18px; color: gold; }
    header button { margin-left: 5px; }
    button { padding: 8px 14px; border-radius: 4px; border: none; cursor: pointer; }
    .primary { background: gold; color: #000; font-weight: bold; }
    .danger { background: crimson; color: #fff; }
    .panel { padding: 10px; }
    .game-box { background: #12345a; margin: 10px; border-radius: 10px; padding: 10px; height: 260px; position: relative; overflow: hidden; }
    #multiplier { font-size: 26px; font-weight: bold; position: absolute; top: 10px; left: 10px; }
    #plane { width: 80px; position: absolute; bottom: 20px; left: 10px; transition: transform 0.08s linear; }
    input { padding: 8px; width: 120px; text-align: center; }
    .controls { margin-top: 10px; }
    .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .modal-content { background: #0c223a; padding: 20px; width: 90%; max-width: 300px; border-radius: 8px; }
    .modal-content h3 { margin-top: 0; }
    .modal-content input { width: 100%; margin-bottom: 10px; padding: 8px; color: #fff; background: #0b1b33; border: 1px solid #444; border-radius: 4px; }
    .hidden { display: none; }
  /* AppsGeyser color override - paste this at the END of your existing <style> block */

/* Ensure page background and text color are forced */
html, body {
  height: 100% !important;
  margin: 0 !important;
  padding: 0 !important;
  background: #081a2b !important;  /* page background (dark) */
  color: #ffffff !important;       /* primary text color */
  -webkit-text-size-adjust: 100% !important;
}

/* Header */
header {
  background: #03101f !important;
  color: #FFD700 !important;
}
header h1 { color: #FFD700 !important; }

/* Main panel and surrounding UI */
.panel { background: transparent !important; color: #ffffff !important; }

/* Game box (main play area) */
.game-box {
  background: #12345a !important;
  border-radius: 10px !important;
  box-shadow: none !important;
  color: #ffffff !important;
}
#multiplier { color: #ffffff !important; }

/* Inputs */
input, .modal-content input {
  background: #0b1b33 !important;
  color: #ffffff !important;
  border: 1px solid rgba(255,255,255,0.12) !important;
}

/* Buttons */
button, .controls button { color: inherit !important; border: none !important; }

/* Primary and danger buttons */
.primary { background: #FFD700 !important; color: #000 !important; font-weight: 700 !important; }
.danger  { background: #d7263d !important; color: #fff !important; }

/* Deposit/Withdraw buttons (white look) */
button[onclick*="deposit"], button[onclick*="withdraw"],
button:where(.deposit, .withdraw) {
  background: #f0f0f0 !important;
  color: #111 !important;
  border-radius: 6px !important;
  box-shadow: none !important;
}

/* Modals / overlays */
.modal { background: rgba(0,0,0,0.8) !important; }
.modal-content {
  background: #0c223a !important;
  color: #ffffff !important;
  border: 1px solid rgba(255,255,255,0.06) !important;
}

/* User info text */
#userInfo, #username, #balance { color: #ffffff !important; }

/* Force large white containers to be transparent */
div, section, main, article { background-color: transparent !important; }

/* Try to cover AppsGeyser wrapper classes */
.app, .webview, .wrapper, .container { background: transparent !important; }

/* Links & pseudo elements */
a { color: #FFD700 !important; }
*::before, *::after { background: transparent !important; }
  </style>
  <meta name="theme-color" content="#03101f">
</head>
<body>

<header>
  <h1>‚úàÔ∏è Ka Ndeke</h1>
  <div>
    <button id="loginBtn" onclick="showLogin()">Login</button>
    <button id="registerBtn" onclick="showRegister()">Register</button>
    <button id="logoutBtn" onclick="logout()" class="hidden">Logout</button>
    <button id="guestBtn" onclick="useGuest()">Guest</button>
  </div>
</header>

<div class="panel">
  <div id="userInfo">Logged in as: <b id="username">Guest</b><br />Balance: <b>ZMW <span id="balance">10.00</span></b></div>
</div>

<div class="game-box">
  <div id="multiplier">1.00x</div>
  <svg id="plane" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <path d="M4 18 C18 18 32 16 46 12 C50 11 54 9 60 8 L58 6 C52 7 48 9 44 10 C30 14 18 16 6 18 Z" fill="#FFD54F"/>
    <path d="M18 18 L36 10 L40 12 L24 20 Z" fill="#FF7043"/>
    <path d="M22 20 L38 22 L36 24 L20 22 Z" fill="#FF7043"/>
    <path d="M6 18 L2 14 L2 18 Z" fill="#FF7043"/>
    <circle cx="46" cy="11" r="2.2" fill="rgba(0,0,0,0.6)"/>
    <path d="M4 18 C18 18 32 16 46 12 C50 11 54 9 60 8" fill="none" stroke="rgba(0,0,0,0.06)" stroke-width="1"/>
  </svg>
</div>

<div class="controls">
  <input type="number" id="betAmount" value="5" min="1" />
  <br /><br />
  <button class="primary" onclick="startGame()">Play</button>
  <button id="cashOutBtn" class="danger" onclick="cashOut()" disabled>Cash Out</button>
  <br /><br />
  <button onclick="deposit()">Deposit ZMW</button>
  <button onclick="withdraw()">Withdraw ZMW</button>
</div>

<div class="modal" id="loginModal">
  <div class="modal-content">
    <h3>Login</h3>
    <input id="loginPhone" placeholder="Phone number" />
    <input id="loginPassword" type="password" placeholder="Password" />
    <button class="primary" onclick="login()">Submit</button>
    <button onclick="hideModals()">Cancel</button>
  </div>
</div>

<div class="modal" id="registerModal">
  <div class="modal-content">
    <h3>Register</h3>
    <input id="regName" placeholder="Full name" />
    <input id="regPhone" placeholder="Phone number" />
    <input id="regPassword" type="password" placeholder="Password" />
    <button class="primary" onclick="register()">Submit</button>
    <button onclick="hideModals()">Cancel</button>
  </div>
</div>

<script>
/* üîí HARD GLOBAL GUARD ‚Äî MUST BE FIRST */

function getBalance() {
  // Prefer persisted guest balance if present, otherwise fall back to in-memory balance
  const stored = localStorage.getItem("guest_balance");

  if (stored !== null) {
    return Number(stored);
  }

  if (typeof balance !== "undefined") {
    return Number(balance || 0);
  }

  return 0;
}

if (typeof refreshBalance !== "function") {
  function refreshBalance() {
    // Placeholder no-op until real refreshBalance is available
    return;
  }
}

/* ============================================================= */
  
const API = "https://ka-ndeke-backend-5dgy.onrender.com/api"; // backend base

let user = { guest: true };
let balance = Number(localStorage.getItem("guest_balance") || 10);
let running = false;
let currentBet = 0;
let roundCrashed = false;
let currentRoundId = null;
let statusPoller = null;
let spectatorPoller = null;

// Helper to safely set multiplier and plane position
function renderMultiplierAndPlane(mult) {
  const m = Number(Number(mult || 1).toFixed(2));
  const multEl = document.getElementById("multiplier");
  const planeEl = document.getElementById("plane");
  if (multEl) multEl.textContent = m.toFixed(2) + "x";
  if (planeEl) {
    const x = m * 15;
    const y = m * -6;
    planeEl.style.transform = `translate(${x}px, ${y}px)`;
  }
}

// Called when server reports a crash for the current round
function handleCrashFromServer() {
  if (!running) return;

  running = false;
  roundCrashed = true;
  if (statusPoller) {
    clearInterval(statusPoller);
    statusPoller = null;
  }

  document.getElementById("cashOutBtn").disabled = true;

  alert("üí• CRASHED");

  currentRoundId = null;
  currentBet = 0;

  renderMultiplierAndPlane(1);
}

const loginModal = document.getElementById("loginModal");
const registerModal = document.getElementById("registerModal");
const loginBtn = document.getElementById("loginBtn");
const registerBtn = document.getElementById("registerBtn");
const logoutBtn = document.getElementById("logoutBtn");
const guestBtn = document.getElementById("guestBtn");

function updateUI() {
  document.getElementById("username").textContent = user.guest ? "Guest" : (user.username || user.name || "User");
  document.getElementById("balance").textContent = Number(balance || 0).toFixed(2);

  if (user.guest) {
    logoutBtn.classList.add("hidden");
    loginBtn.classList.remove("hidden");
    registerBtn.classList.remove("hidden");
    guestBtn.classList.remove("hidden");
  } else {
    logoutBtn.classList.remove("hidden");
    loginBtn.classList.add("hidden");
    registerBtn.classList.add("hidden");
    guestBtn.classList.add("hidden");
  }
}
updateUI();

function stopSpectatorPoll() {
  if (spectatorPoller) {
    clearInterval(spectatorPoller);
    spectatorPoller = null;
  }
}

// Spectator poll: polls public round status and renders multiplier/plane.
// Uses startedAt to locally compute a live multiplier between server updates.
function startSpectatorPoll(intervalMs = 200) {
  if (spectatorPoller) return;

  spectatorPoller = setInterval(async () => {
    try {
      // If a player has joined a round (running === true), stop spectator polling
      if (running) {
        stopSpectatorPoll();
        return;
      }

      const res = await fetch(`${API}/game/status`);
      if (!res.ok) {
        // Keep the UI in spectator mode even if server returns non-OK
        return;
      }
      const data = await res.json().catch(() => null);
      if (!data) return;

      // If server provides startedAt, compute local live multiplier (linear model as server uses)
      let liveMult = 1;
      if (data.startedAt) {
        const elapsedMs = Date.now() - Number(data.startedAt);
        liveMult = 1 + (elapsedMs / 1000) * 1; // growthPerSecond = 1 (matches server)
      } else if (data.multiplier) {
        liveMult = Number(data.multiplier);
      }

      // If server indicates crashed, show exact crash point and return
      if (data.status === "crashed") {
        renderMultiplierAndPlane(data.multiplier ?? data.crashPoint ?? 1);
        // no alert for spectators; keep polling to catch next round
        return;
      }

      // Render interpolated multiplier for smooth spectator animation
      renderMultiplierAndPlane(liveMult);
    } catch (err) {
      // transient errors shouldn't stop the poller
      console.error("spectator poll error", err);
    }
  }, intervalMs);
}

// Start spectator polling as soon as script runs
startSpectatorPoll();

/* GAME LOGIC */

// Start a round as a player: tell the server you joined (server is authoritative)
async function startGame() {
  if (running) return;

  const bet = Number(document.getElementById("betAmount").value);

  if (!bet || isNaN(bet) || bet <= 0) {
    return alert("Invalid bet amount");
  }
										
  try {
    // include Authorization header when token exists
    const token = localStorage.getItem("token");
    const headers = { "Content-Type": "application/json" };
    if (token) headers["Authorization"] = "Bearer " + token;

    const res = await fetch(API + "/game/start", {
      method: "POST",
      headers,
      body: JSON.stringify({
        betAmount: bet,
        userId: user.guest ? "guest" : user.id
      })
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      return alert(data.error || "Failed to start round");
    }

    // sync balance if server provided it
    if (data.balance !== undefined) {
      balance = Number(data.balance);
      updateUI();
    }

    currentRoundId = data.roundId;
    currentBet = bet;
    roundCrashed = false;
    running = true;
    updateUI();

    // Start player poller which drives plane and enables cash-out.
    // Use the public status endpoint (server is authoritative).
    if (statusPoller) {
      clearInterval(statusPoller);
      statusPoller = null;
    }

    statusPoller = setInterval(async () => {
      try {
        const res = await fetch(`${API}/game/status`);
        if (!res.ok) return;
        const d = await res.json().catch(() => null);
        if (!d) return;

        // compute live multiplier using startedAt if available
        let liveMult = 1;
        if (d.startedAt) {
          const elapsedMs = Date.now() - Number(d.startedAt);
          liveMult = 1 + (elapsedMs / 1000) * 1;
        } else if (d.multiplier) {
          liveMult = Number(d.multiplier);
        }

        if (!running) return;

        if (d.status === "running") {
          renderMultiplierAndPlane(liveMult);
          document.getElementById("cashOutBtn").disabled = false;
        } else if (d.status === "crashed") {
          // Ensure exact crash point shown then handle crash
          renderMultiplierAndPlane(d.multiplier ?? d.crashPoint ?? 1);
          handleCrashFromServer();
        }
      } catch (err) {
        console.error("player poll error", err);
      }
    }, 120);

  } catch (err) {
    console.error("startGame error", err);
    alert("Failed to start round: " + (err.message || err));
  }
}

async function cashOut() {
  if (roundCrashed) {
    alert("Too late ‚Äî round already crashed");
    return;
  }

  // safety check: ask server for current status
  try {
    const statusRes = await fetch(`${API}/game/status`);
    const statusData = await statusRes.json().catch(() => ({}));
    if (statusData.status === "crashed") {
      handleCrashFromServer();
      return;
    }
  } catch (err) {
    console.warn("Safety latch status check failed", err);
    alert("Round status unclear. Please wait.");
    return;
  }

  if (!running) {
    alert("No active round");
    return;
  }

  // hard stop: stop player poller
  running = false;
  if (statusPoller) {
    clearInterval(statusPoller);
    statusPoller = null;
  }

  // prevent double cashout
  document.getElementById("cashOutBtn").disabled = true;

  try {
    // include Authorization header when token exists
    const token = localStorage.getItem("token");
    const headers = { "Content-Type": "application/json" };
    if (token) headers["Authorization"] = "Bearer " + token;

    const res = await fetch(API + "/game/cashout", {
      method: "POST",
      headers,
      body: JSON.stringify({
        userId: user.guest ? "guest" : user.id
      })
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data.error || "Cash out failed");

    // sync balance if provided
    if (data.balance !== undefined) {
      balance = Number(data.balance);
      updateUI();
    }

    if (data.win) {
      alert("You won ZMW " + Number(data.payout).toFixed(2));
    } else {
      alert("Crashed!");
    }
  } catch (err) {
    alert(err.message || "Cash out failed");
    return;
  }

  // full reset of local player state
  currentRoundId = null;
  currentBet = 0;
  roundCrashed = false;
  renderMultiplierAndPlane(1);
  updateUI();
}

/* AUTH MODALS */
function showLogin() { loginModal.style.display = "flex"; }
function showRegister() { registerModal.style.display = "flex"; }
function hideModals() { loginModal.style.display = "none"; registerModal.style.display = "none"; }

async function refreshBalance() {
  const token = localStorage.getItem("token");
  if (!token) {
    console.warn("No token available for refreshBalance");
    return;
  }
  const headers = { "Content-Type": "application/json", "Authorization": "Bearer " + token };

  try {
    const res = await fetch(API + "/users/me", { headers });
    const data = await res.json().catch(() => ({}));
    if (res.ok) {
      balance = Number(data.balance ?? balance);
      user = data || user;
      updateUI();
    } else {
      console.warn("refreshBalance: server returned non-OK", data);
    }
  } catch (err) {
    console.error("refreshBalance error", err);
  }
}

async function login() {
  if (!loginPhone.value || !loginPassword.value) return alert("Phone and password required");
  try {
    const res = await fetch(API + "/auth/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ phone: loginPhone.value, password: loginPassword.value })
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data.error || "Login failed");

    localStorage.setItem("token", data.token);
    localStorage.setItem("username", data.user?.username || "");
    user = data.user ?? { guest: false };
    balance = Number(data.user?.balance ?? data.balance ?? 5);
    hideModals();
    updateUI();
  } catch (err) {
    alert(err.message);
  }
}

async function register() {
  if (!regName.value || !regPhone.value || !regPassword.value) return alert("Username, phone and password required");
  try {
    const res = await fetch(API + "/auth/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username: regName.value, phone: regPhone.value, password: regPassword.value })
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) throw new Error(data.error || "Register failed");

    localStorage.setItem("token", data.token);
    localStorage.setItem("username", data.user?.username || "");
    user = data.user ?? { guest: false };
    balance = Number(data.user?.balance ?? data.balance ?? 10);
    hideModals();
    updateUI();
  } catch (err) {
    alert(err.message);
  }
}

function logout() {
  user = { guest: true };

  const stored = localStorage.getItem("guest_balance");
  balance = stored !== null ? Number(stored) : 10;

  localStorage.removeItem("token");
  updateUI();
}

/* GUEST MODE */
function useGuest() {
  user = { guest: true, name: "Guest" };

  const stored = localStorage.getItem("guest_balance");
  balance = stored !== null ? Number(stored) : 10;

  updateUI();
}

/* WALLET (fixed endpoints and better error handling) */
async function deposit() {
  const amt = prompt("Enter deposit amount");
  if (!amt || isNaN(amt) || amt <= 0) return alert("Invalid amount");

  if (user.guest) {
    balance += Number(amt);
    localStorage.setItem("guest_balance", balance);
    updateUI();
    alert("Deposit succeeded");
    return;
  }

  const token = localStorage.getItem("token");
  if (!token) return alert("You must be logged in to deposit");

  try {
    const res = await fetch(API + "/users/deposit", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": "Bearer " + token },
      body: JSON.stringify({ amount: Number(amt) })
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      return alert(data.error || data.message || `Deposit failed (HTTP ${res.status})`);
    }

    if (data.balance !== undefined) {
      balance = Number(data.balance);
      user = data;
      updateUI();
    } else {
      await refreshBalance();
    }
    alert("Deposit succeeded");
  } catch (err) {
    console.error("deposit error", err);
    alert("Network error during deposit: " + (err.message || err));
  }
}

async function withdraw() {
  const amt = prompt("Enter withdraw amount");
  if (!amt || isNaN(amt) || amt <= 0) return alert("Invalid amount");

  if (user.guest) {
    if (amt > balance) return alert("Insufficient balance");
    balance -= Number(amt);
    localStorage.setItem("guest_balance", balance);
    updateUI();
    return;
  }

  const token = localStorage.getItem("token");
  if (!token) return alert("You must be logged in to withdraw");

  try {
    const res = await fetch(API + "/users/withdraw", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": "Bearer " + token },
      body: JSON.stringify({ amount: Number(amt) })
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) return alert(data.error || data.message || `Withdraw failed (HTTP ${res.status})`);

    if (data.balance !== undefined) {
      balance = Number(data.balance);
      user = data;
      updateUI();
    } else {
      await refreshBalance();
    }
    alert("Withdraw succeeded");
  } catch (err) {
    console.error("withdraw error", err);
    alert("Network error during withdraw: " + (err.message || err));
  }
}
</script>

</body>
  </html>
